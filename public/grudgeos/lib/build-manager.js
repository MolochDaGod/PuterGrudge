/**
 * BuildManager - Agent Package Creation and Bundling System
 * 
 * Provides structured workflows for agents to:
 * - Create deployable packages (web apps, games, agents)
 * - Bundle code with proper artifact naming
 * - Generate checksums for verification
 * - Deploy to Puter hosting or external providers
 * 
 * NO Apache/VM needed - uses Puter-native hosting
 */

export const BUILD_TEMPLATES = {
  webApp: {
    id: 'web-app',
    name: 'Web Application',
    structure: {
      'index.html': '<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>{{APP_NAME}}</title>\n  <link rel="stylesheet" href="styles.css">\n</head>\n<body>\n  <div id="app"></div>\n  <script type="module" src="main.js"></script>\n</body>\n</html>',
      'styles.css': '/* Generated by CloudPilot AI */\n:root {\n  --primary: #8b5cf6;\n  --background: #0a0a0f;\n  --foreground: #e8e8ff;\n}\n\n* { box-sizing: border-box; margin: 0; padding: 0; }\nbody { font-family: system-ui, sans-serif; background: var(--background); color: var(--foreground); }',
      'main.js': '// Generated by CloudPilot AI\nconsole.log("{{APP_NAME}} loaded");',
    },
    buildCommand: null,
    deployTarget: 'puter',
  },

  staticSite: {
    id: 'static-site',
    name: 'Static Website',
    structure: {
      'index.html': '<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>{{APP_NAME}}</title>\n  <style>\n    body { font-family: system-ui; max-width: 800px; margin: 0 auto; padding: 2rem; }\n  </style>\n</head>\n<body>\n  <h1>{{APP_NAME}}</h1>\n  <p>Welcome to your new site!</p>\n</body>\n</html>',
    },
    buildCommand: null,
    deployTarget: 'puter',
  },

  phaserGame: {
    id: 'phaser-game',
    name: 'Phaser Game',
    structure: {
      'index.html': '<!DOCTYPE html>\n<html>\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>{{APP_NAME}}</title>\n  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>\n</head>\n<body style="margin:0;overflow:hidden">\n  <script src="game.js"></script>\n</body>\n</html>',
      'game.js': `// {{APP_NAME}} - Phaser Game
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  backgroundColor: '#1a1a25',
  scene: { preload, create, update }
};

const game = new Phaser.Game(config);

function preload() {}
function create() {
  this.add.text(400, 300, '{{APP_NAME}}', { fontSize: '32px', fill: '#fff' }).setOrigin(0.5);
}
function update() {}`,
    },
    buildCommand: null,
    deployTarget: 'puter',
  },

  multiplayerGame: {
    id: 'multiplayer-game',
    name: 'Multiplayer Game (WebSocket)',
    structure: {
      'index.html': '<!DOCTYPE html>\n<html>\n<head>\n  <meta charset="UTF-8">\n  <title>{{APP_NAME}}</title>\n</head>\n<body>\n  <div id="game"></div>\n  <script src="client.js"></script>\n</body>\n</html>',
      'client.js': `// {{APP_NAME}} - Multiplayer Client
const ws = new WebSocket('wss://your-server.puter.site/ws');
ws.onopen = () => console.log('Connected');
ws.onmessage = (e) => console.log('Message:', e.data);
ws.onerror = (e) => console.error('Error:', e);`,
      'server.js': `// {{APP_NAME}} - Game Server
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

const players = new Map();

wss.on('connection', (ws) => {
  const playerId = Date.now().toString(36);
  players.set(playerId, { ws, x: 0, y: 0 });
  
  ws.on('message', (data) => {
    const msg = JSON.parse(data);
    broadcast({ playerId, ...msg });
  });
  
  ws.on('close', () => players.delete(playerId));
});

function broadcast(data) {
  const msg = JSON.stringify(data);
  players.forEach(p => p.ws.send(msg));
}`,
    },
    buildCommand: null,
    deployTarget: 'puter',
  },

  agentExtension: {
    id: 'agent-extension',
    name: 'Agent Extension',
    structure: {
      'manifest.json': '{\n  "name": "{{APP_NAME}}",\n  "version": "1.0.0",\n  "type": "agent-extension",\n  "entry": "index.js",\n  "capabilities": ["ai", "storage", "network"]\n}',
      'index.js': `// {{APP_NAME}} - Agent Extension
export default {
  name: '{{APP_NAME}}',
  
  async init(context) {
    console.log('Extension initialized');
  },
  
  async execute(task, context) {
    // Process task
    return { success: true, result: null };
  },
  
  async cleanup() {
    console.log('Extension cleanup');
  }
};`,
    },
    buildCommand: null,
    deployTarget: 'local',
  },
};

export class BuildManager {
  constructor(options = {}) {
    this.projectRoot = options.projectRoot || '/projects';
    this.outputDir = options.outputDir || '/builds';
    this.puter = options.puter || (typeof window !== 'undefined' ? window.puter : null);
    this.builds = new Map();
  }

  async createProject(templateId, appName, options = {}) {
    const template = BUILD_TEMPLATES[templateId];
    if (!template) {
      throw new Error(`Unknown template: ${templateId}`);
    }

    const projectId = `${appName.toLowerCase().replace(/\s+/g, '-')}-${Date.now().toString(36)}`;
    const projectPath = `${this.projectRoot}/${projectId}`;

    const files = [];
    for (const [filename, content] of Object.entries(template.structure)) {
      const processedContent = content.replace(/\{\{APP_NAME\}\}/g, appName);
      files.push({ path: `${projectPath}/${filename}`, content: processedContent });
    }

    const project = {
      id: projectId,
      name: appName,
      template: templateId,
      path: projectPath,
      files,
      createdAt: new Date().toISOString(),
      status: 'created',
    };

    if (this.puter) {
      await this.puter.kv.set(`project:${projectId}`, JSON.stringify(project));
    }

    return project;
  }

  async buildProject(projectId, options = {}) {
    const build = {
      id: `build-${Date.now().toString(36)}`,
      projectId,
      startedAt: new Date().toISOString(),
      status: 'building',
      artifacts: [],
      logs: [],
    };

    this.builds.set(build.id, build);

    try {
      build.logs.push({ time: Date.now(), msg: 'Build started' });

      const project = await this.getProject(projectId);
      if (!project) {
        throw new Error(`Project ${projectId} not found`);
      }

      build.logs.push({ time: Date.now(), msg: `Building template: ${project.template}` });

      const bundlePath = `${this.outputDir}/${projectId}`;
      const writtenFiles = [];
      let totalSize = 0;

      if (this.puter) {
        await this.puter.fs.mkdir(bundlePath, { recursive: true });
        
        for (const file of project.files) {
          const relativePath = file.path.replace(`${this.projectRoot}/${projectId}/`, '');
          const outputPath = `${bundlePath}/${relativePath}`;
          
          const outputDir = outputPath.substring(0, outputPath.lastIndexOf('/'));
          if (outputDir !== bundlePath) {
            await this.puter.fs.mkdir(outputDir, { recursive: true });
          }
          
          await this.puter.fs.write(outputPath, file.content);
          writtenFiles.push({ path: relativePath, size: file.content.length });
          totalSize += file.content.length;
          build.logs.push({ time: Date.now(), msg: `Written: ${relativePath}` });
        }
      }

      const bundleContent = project.files.map(f => `// ${f.path}\n${f.content}`).join('\n\n');
      const checksum = this.generateChecksum(bundleContent);
      
      const manifest = {
        projectId,
        name: project.name,
        template: project.template,
        files: writtenFiles,
        buildId: build.id,
        checksum,
        totalSize,
        builtAt: new Date().toISOString(),
      };

      if (this.puter) {
        await this.puter.fs.write(
          `${bundlePath}/manifest.json`,
          JSON.stringify(manifest, null, 2)
        );
        build.logs.push({ time: Date.now(), msg: 'Manifest written' });
      }

      build.artifacts.push({
        type: 'bundle',
        path: bundlePath,
        size: totalSize,
        fileCount: writtenFiles.length,
        checksum,
        manifest,
      });

      build.logs.push({ time: Date.now(), msg: 'Build completed successfully' });
      build.status = 'success';
      build.completedAt = new Date().toISOString();

    } catch (error) {
      build.status = 'failed';
      build.error = error.message;
      build.logs.push({ time: Date.now(), msg: `Build failed: ${error.message}` });
    }

    if (this.puter) {
      await this.puter.kv.set(`build:${build.id}`, JSON.stringify(build));
    }

    return build;
  }

  async deployProject(projectId, target = 'puter', options = {}) {
    const deployment = {
      id: `deploy-${Date.now().toString(36)}`,
      projectId,
      target,
      startedAt: new Date().toISOString(),
      status: 'deploying',
      url: null,
      logs: [],
    };

    try {
      deployment.logs.push({ time: Date.now(), msg: `Starting deployment to ${target}` });

      if (target === 'puter' && this.puter) {
        const subdomain = options.subdomain || projectId.replace(/[^a-z0-9-]/gi, '-');
        const sourcePath = `${this.outputDir}/${projectId}`;
        
        deployment.logs.push({ time: Date.now(), msg: `Checking build artifacts at ${sourcePath}` });
        
        const manifestPath = `${sourcePath}/manifest.json`;
        let manifest = null;
        try {
          const manifestContent = await this.puter.fs.read(manifestPath);
          manifest = JSON.parse(manifestContent);
          deployment.logs.push({ time: Date.now(), msg: `Manifest verified: ${manifest.checksum}` });
        } catch (e) {
          deployment.logs.push({ time: Date.now(), msg: 'Warning: No manifest found, deploying raw files' });
        }

        deployment.logs.push({ time: Date.now(), msg: `Creating hosting at ${subdomain}.puter.site` });
        
        try {
          await this.puter.hosting.create(subdomain, sourcePath);
        } catch (hostingError) {
          if (hostingError.message?.includes('already exists')) {
            deployment.logs.push({ time: Date.now(), msg: 'Site exists, updating...' });
            await this.puter.hosting.update(subdomain, sourcePath);
          } else {
            throw hostingError;
          }
        }
        
        deployment.url = `https://${subdomain}.puter.site`;
        deployment.subdomain = subdomain;
        deployment.status = 'live';
        deployment.manifest = manifest;
        deployment.logs.push({ time: Date.now(), msg: `Deployed successfully to ${deployment.url}` });
        
      } else if (target === 'local') {
        deployment.url = `file://${this.outputDir}/${projectId}/index.html`;
        deployment.status = 'ready';
        deployment.logs.push({ time: Date.now(), msg: 'Local deployment ready' });
        
      } else {
        deployment.status = 'pending';
        deployment.message = `External deployment to ${target} requires manual setup`;
        deployment.instructions = DEPLOYMENT_TARGETS[target]?.setup || 'Configure deployment manually';
        deployment.logs.push({ time: Date.now(), msg: `External deployment queued for ${target}` });
      }

      deployment.completedAt = new Date().toISOString();

    } catch (error) {
      deployment.status = 'failed';
      deployment.error = error.message;
      deployment.logs.push({ time: Date.now(), msg: `Deployment failed: ${error.message}` });
    }

    if (this.puter) {
      await this.puter.kv.set(`deployment:${deployment.id}`, JSON.stringify(deployment));
    }

    return deployment;
  }

  async getDeploymentStatus(deploymentId) {
    if (!this.puter) return null;
    const data = await this.puter.kv.get(`deployment:${deploymentId}`);
    return data ? JSON.parse(data) : null;
  }

  async listDeployments(projectId = null) {
    if (!this.puter) return [];
    
    const deployments = [];
    return deployments;
  }

  generateChecksum(content) {
    let hash = 0;
    const str = typeof content === 'string' ? content : JSON.stringify(content);
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16).padStart(8, '0');
  }

  async listProjects() {
    if (!this.puter) return [];
    
    const keys = [];
    const projects = [];
    
    return projects;
  }

  async getProject(projectId) {
    if (!this.puter) return null;
    
    const data = await this.puter.kv.get(`project:${projectId}`);
    return data ? JSON.parse(data) : null;
  }
}

export const DEPLOYMENT_TARGETS = {
  puter: {
    name: 'Puter Hosting',
    description: 'Free static hosting at *.puter.site',
    free: true,
    supports: ['static', 'spa'],
    setup: 'Automatic via Puter.js',
  },
  vercel: {
    name: 'Vercel',
    description: 'Frontend cloud with serverless functions',
    free: true,
    supports: ['static', 'spa', 'serverless', 'nextjs'],
    setup: 'Requires VERCEL_TOKEN environment variable',
  },
  netlify: {
    name: 'Netlify',
    description: 'JAMstack hosting with functions',
    free: true,
    supports: ['static', 'spa', 'serverless'],
    setup: 'Requires NETLIFY_AUTH_TOKEN environment variable',
  },
  cloudflare: {
    name: 'Cloudflare Pages',
    description: 'Edge hosting with Workers',
    free: true,
    supports: ['static', 'spa', 'edge-functions'],
    setup: 'Requires CF_API_TOKEN environment variable',
  },
};

export default BuildManager;
